<%= stylesheet_link_tag "widget_panel/style" %>

<% unless current_page?(component_named_expanded_path) %>
<%# Inline Widget (My Widgets) %>
<section class="widget_panel text-primary relative">
  <header class="flex items-center justify-between px-8">
    <p id="widgets-heading" role="heading" aria-level="1" class="my-0 subtitle2">My Widgets</p>
    <mx-button btn-type="text" icon="icon icon-plus-circle">
      Add/Remove
      <span class="add-remove-widgets">Widgets</span>
    </mx-button>
  </header>
  <% if @widgets.any? %>
    <p id="reorder-help" class="sr-only">
      Activate the reorder button and use the arrow keys to reorder the list. Press Escape or Tab to cancel the reordering.
    </p>
    <ol class="widget-grid overflow-hidden md:pb-96" aria-labelledby="widgets-heading">
      <% @widgets.each do |widget| %>
        <li data-widget-id="<%= widget.id %>" data-widget-component="<%= widget.component %>" data-widget-name="<%= widget.name %>">
          <%= render widget.view_component.new %>
        </li>
      <% end %>
    </ol>
  <% end %>
  <div class="empty-state text-center <%= @widgets.any? ? "hidden" : "" %>">
    <div class="text-h5 my-0 mt-24 mb-8">
      No widgets to show yet
    </div>
    <div class="mb-16">
      Widgets offer a convenient pulse check of your real estate ecosystem by surfacing essential activity and insights right from your dashboard. Select “Add/Remove Widgets” to get started.
    </div>
    <%= image_tag "empty-state.svg", alt: "", role: "presentation", class: "mx-auto", style: "width: 200px;" %>
  </div>
  <div class="panel-loading absolute inset-0 w-full h-full hidden items-center justify-center bg-gray opacity-50">
    <mx-circular-progress size="10%"></mx-circular-progress>
  </div>
</section>

<%# Inline Widget Script (My Widgets) %>
<script type="module">
const SESSION_ID = '<%= params[:session_id] %>';
const root = document.querySelector('.widget_panel');

document.addEventListener('DOMContentLoaded', () => {
  logEvent('widget_dashboard_load', { timeMs: performance.now() })
});

// Notify parent window of height changes
const resizeObserver = new ResizeObserver(entries => {
  const height = entries[0].contentRect.height;
  window.parent.postMessage(
    { type: 'RESIZE', payload: { component: 'widget_panel', height } },
    '*'
  );
});
resizeObserver.observe(root);

const addButton = root.querySelector('mx-button');
if (addButton) {
  addButton.addEventListener('click', () => {
    const url = `${window.location.origin}<%= component_named_expanded_path %>${window.location.search}`;
    setLoading(true);
    window.parent.postMessage({ type: 'EXPAND', payload: { url } }, '*');
  });
}

window.addEventListener('message', e => {
  const { type, payload } = e.data;
  if (type === 'REMOVE') removeWidget(payload.component);
  else if (e.data.type === "SET_LOADING") {
    const { isLoading, component } = e.data.payload;
    if (component === 'widget_panel') setLoading(isLoading);
  }
});

function setLoading(isLoading) {
  const loading = root.querySelector(".panel-loading");
  if (isLoading) {
    loading.classList.replace("hidden", "flex");
  } else {
    loading.classList.replace("flex", "hidden");
  }
}

function removeWidget(component) {
  const widget = root.querySelector(`[data-widget-component="${component}"]`);
  destroyUserWidget(widget.dataset.widgetId);
  logEvent('widget_remove_via_menu');
  widget.remove();
  if (!root.querySelector('li')) {
    root.querySelector('.empty-state').classList.remove('hidden');
  } else {
    resetWidgetOrderAttributes();
  }
}

function logEvent(eventType, eventData) {
  _fetch(`/api/events/?session_id=${SESSION_ID}`, {
    method: 'POST',
    body: JSON.stringify({
      event_type: eventType,
      event_data: eventData,
      component: 'widget_panel',
     })
  });
}

// Drag sorting

const KEYBOARD_DRAG_CLASSES = ['transform', '-translate-y-10'];
const MOUSE_DRAG_CLASSES = ['z-50', 'pointer-events-none'];
const dragHandleHtml = name => `
  <div class="touch-drag-handle mr-10">
    <button
      class="keyboard-drag-button flex pointer-events-none"
      aria-describedby="reorder-help"
      aria-label="Reorder ${name}"
    >
      <span class="icon icon-drag"></span>
    </button>
  </div>`;
let draggedWidget; // Widget being dragged
let overWidget; // Widget being dragged over
let offsetX, offsetY; // Pointer offset from top left of widget when dragging started

// Add drag handles and event listeners
const widgets = root.querySelectorAll('li');
widgets.forEach((widget, i) => {
  const header = widget.querySelector('header');
  header.insertAdjacentHTML(
    'afterbegin',
    dragHandleHtml(widget.dataset.widgetName)
  );
  header.classList.add('cursor-move');
  widget.addEventListener('mousedown', onPointerDown);
  widget.addEventListener('touchstart', onPointerDown);
  widget.addEventListener('mouseover', onMouseOver);
  const keyboardDragButton = widget.querySelector('.keyboard-drag-button');
  keyboardDragButton.addEventListener('keydown', onKeyDown);
});
resetWidgetOrderAttributes();

function onPointerDown(e) {
  let handle =
    e.type === 'mousedown'
      ? e.target.closest('header')
      : e.target.closest('.touch-drag-handle');
  if (!handle) return; // Do not drag unless dragging by the drag handle
  e.preventDefault();
  draggedWidget = e.target.closest('li');
  draggedWidget.classList.add(...MOUSE_DRAG_CLASSES);
  const { clientX, clientY } = getPointer(e);
  offsetX = clientX - draggedWidget.offsetLeft;
  offsetY = clientY - draggedWidget.offsetTop;
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('touchmove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  window.addEventListener('touchend', onPointerUp);
}

function onMouseOver(e) {
  if (!draggedWidget || e.buttons === 0) return; // Only drag if mouse is down
  e.preventDefault();
  visuallyReorder(e.target.closest('li'));
}

function onPointerMove(e) {
  if (!draggedWidget) return;
  const rect = draggedWidget.getBoundingClientRect();
  const { clientX, clientY } = getPointer(e);
  const x = clientX - draggedWidget.offsetLeft - offsetX;
  const y = clientY - draggedWidget.offsetTop - offsetY;
  draggedWidget.style.transform = `translate(${x}px, ${y}px)`;
  if (e.type === 'touchmove') {
    // Since there is no mouseover event for touch, we need to check for element using elementFromPoint
    const target = document.elementFromPoint(clientX, clientY);
    if (!target) return;
    const targetWidget = target.closest('li');
    if (targetWidget) visuallyReorder(targetWidget);
  }
}

function onPointerUp(e) {
  if (!draggedWidget) return;
  draggedWidget.style.transform = '';
  draggedWidget.classList.remove(...MOUSE_DRAG_CLASSES);
  reorderWidgetElements();
  draggedWidget = null;
  window.removeEventListener('mousemove', onPointerMove);
  window.removeEventListener('touchmove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  window.addEventListener('touchend', onPointerUp);
  // TODO: Persist new order
}

function onKeyDown(e) {
  if (['Enter', ' '].includes(e.key)) {
    if (draggedWidget) return keyboardDrop(e);
    return keyboardPickUp(e);
  }
  if (!draggedWidget) return;
  if (['Tab', 'Escape'].includes(e.key)) return keyboardCancel();
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
    return keyboardMove(e);
  }
}

function keyboardPickUp(e) {
  e.preventDefault();
  draggedWidget = e.target.closest('li');
  document.activeElement.setAttribute('aria-pressed', 'true');
  draggedWidget.classList.add(...KEYBOARD_DRAG_CLASSES);
}

function keyboardMove(e) {
  e.preventDefault();
  const order = getOrder(draggedWidget);
  const widgets = Array.from(root.querySelectorAll('li')).sort(
    (a, b) => getOrder(a) - getOrder(b)
  );
  if (['ArrowUp', 'ArrowLeft'].includes(e.key) && order !== 0) {
    visuallyReorder(widgets[order - 1]);
  } else if (
    ['ArrowDown', 'ArrowRight'].includes(e.key) &&
    order !== widgets.length - 1
  ) {
    visuallyReorder(widgets[order + 1]);
  }
}

function keyboardCancel() {
  overWidget = null;
  keyboardDrop();
}

function keyboardDrop(e) {
  if (!draggedWidget) return;
  if (e) e.preventDefault();
  draggedWidget.classList.remove(...KEYBOARD_DRAG_CLASSES);
  reorderWidgetElements();
  document.activeElement.setAttribute('aria-pressed', 'false');
  draggedWidget = null;
}

function visuallyReorder(newOverWidget) {
  // Safari is slow to update the DOM, so while dragging, we only update the CSS order attribute.
  // This also allows us to cancel keyboard dragging by simply reverting the order attributes.
  overWidget = newOverWidget;
  root.querySelectorAll('li').forEach(widget => {
    if (widget === draggedWidget) widget.dataset.order = getOrder(overWidget);
    else if (getOrder(overWidget) > getOrder(draggedWidget)) {
      if (
        getOrder(widget) > getOrder(draggedWidget) &&
        getOrder(widget) <= getOrder(overWidget)
      ) {
        widget.dataset.order = getOrder(widget) - 1;
      }
    } else {
      if (
        getOrder(widget) < getOrder(draggedWidget) &&
        getOrder(widget) >= getOrder(overWidget)
      ) {
        widget.dataset.order = getOrder(widget) + 1;
      }
    }
  });
  // Apply the new order attributes using the dataset values set above
  root.querySelectorAll('li').forEach(widget => {
    widget.style.order = widget.dataset.order;
    widget.removeAttribute('data-order');
  });
}

function reorderWidgetElements() {
  const focused = document.activeElement;
  if (overWidget && getOrder(draggedWidget) !== getIndex(draggedWidget)) {
    const orderedWidgets = Array.from(root.querySelectorAll('li')).sort(
      (a, b) => getOrder(a) - getOrder(b)
    );
    orderedWidgets.forEach(widget => draggedWidget.parentElement.appendChild(widget));
    updateUserWidgets(orderedWidgets.map(w => w.dataset.widgetId));
    logEvent('widget_reorder_widgets', null, draggedWidget.dataset.widgetComponent);
    overWidget = null;
  }
  resetWidgetOrderAttributes();
  focused.focus(); // Keep focus on the keyboard-drag-button
}

function resetWidgetOrderAttributes() {
  root.querySelectorAll('li').forEach((widget, i) => {
    widget.style.order = i;
  });
}

function getOrder(el) {
  return parseInt(el.style.order || 0);
}

function getIndex(el) {
  return Array.from(root.querySelectorAll('li')).indexOf(el);
}

function getPointer(e) {
  if (e.type === 'touchstart' || e.type === 'touchmove') {
    return e.touches[0];
  } else {
    return e;
  }
}

function updateUserWidgets(orderedWidgetIds) {
  if (!draggedWidget) return;
  _fetch(`/api/user_widgets/?session_id=${SESSION_ID}`, {
    method: 'PATCH',
    body: JSON.stringify({ widget_ids: orderedWidgetIds })
  });
}
function destroyUserWidget(widgetId) {
  return _fetch(`/api/user_widgets/${widgetId}?session_id=${SESSION_ID}`, {
    method: 'DELETE',
  })
}
async function _fetch(url, options) {
  options = { ...options, headers: { 'Content-Type': 'application/json' } }
  const response = await fetch(url, options)
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
}
</script>

<% else %>
<%# Expanded Widget (Widget Library) %>
<div class="widget_panel w-screen h-screen">
  <mx-modal large close-on-escape="false">
    <div slot="header-left">Library</div>
    <div class="widget-library-grid">
      <% @active_widgets.each do |widget| %>
        <% added = @widgets.include?(widget) %>
        <div data-widget-id="<%= widget.id %>" class="px-16 pt-16 pb-24 bg-white rounded-lg">
          <div class="px-8 mb-20">
            <mx-button btn-type="text" icon="icon icon-plus-circle" class="add-button <%= added ? "hidden" : "" %>">
              <span class="button-text">Add widget</span>
            </mx-button>
            <div class="remove-button-wrapper relative <%= added ? "" : "hidden" %>">
              <!-- It was cleaner to do this with two buttons and CSS instead of JavaScript. -->
              <!-- Remove button that is hovered/focused/active.  -->
              <mx-button btn-type="text" icon="icon icon-minus-circle" class="remove-button absolute left-0 opacity-0 hover:opacity-100 focus-within:opacity-100">
                <span class="button-text">Remove from Dashboard</span>
              </mx-button>
              <!-- Not hovered/focused/active -->
              <mx-button btn-type="text" icon="icon icon-checkbox-circle" class="added-button pointer-events-none" disabled>
                Added to Dashboard
              </mx-button>
            </div>
          </div>
          <%= render widget.view_component.new(library_mode: true) %>
          <div class="px-8 mt-20">
            <p role="heading" aria-level="3" class="overline2 my-0 mb-8">
              Description
            </p>
            <p class="text-4 my-0">
              <%= widget.description %>
            </p>
          </div>
        </div>
      <% end %>
    </div>
  </mx-modal>
</div>

<%# Expanded Widget Script (Widget Library) %>
<script type="module">
let activeRequests = [];
let isWaitingToClose = false;
const SESSION_ID = '<%= params[:session_id] %>';
const root = document.querySelector('.widget_panel');
const sendCloseMessage = async () => {
  if (isWaitingToClose) return;
  isWaitingToClose = true;
  await Promise.all(activeRequests);
  window.parent.postMessage(
    { type: "CLOSE_EXPANDED", payload: {} },
    "*"
  );
}
const modal = root.querySelector("mx-modal");
const observer = new MutationObserver(mutations => {
  requestAnimationFrame(() => {
    modal.isOpen = true;
    window.parent.postMessage(
      { type: "SET_LOADING", payload: { component: 'widget_panel', isLoading: false } },
      "*"
    );
  });
  observer.disconnect();
});
observer.observe(root, { subtree: true, childList: true });
modal.addEventListener("mxClose", sendCloseMessage);
/* The close-on-escape behavior provided by mx-modal does not work in an iframe. */
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") sendCloseMessage();
});
document.addEventListener('DOMContentLoaded', () => {
  logEvent('widget_open_library', { timeMs: performance.now() })
});

const addButtons = root.querySelectorAll(".add-button");
addButtons.forEach((button) => {
  button.addEventListener("click", async (e) => {
    const widgetId = e.target.closest('[data-widget-id]').dataset.widgetId;
    // Show "Adding widget" button
    const addButton = e.target.closest('mx-button');
    const removeButtonWrapper = addButton.parentElement.querySelector('.remove-button-wrapper');
    addButton.icon = 'icon icon-arrows-clockwise';
    addButton.querySelector('.button-text').innerText = 'Adding widget'
    addButton.disabled = true;
    try {
      await restoreUserWidget(widgetId);
      // Replace add button with remove button
      addButton.classList.add('hidden')
      removeButtonWrapper.classList.remove('hidden');
    } catch(err) {
      console.error(err);
    } finally {
      addButton.icon = 'icon icon-plus-circle';
      addButton.querySelector('.button-text').innerText = 'Add widget'
      addButton.disabled = false;
    }
  });
});
const removeButtons = root.querySelectorAll(".remove-button");
removeButtons.forEach((button) => {
  button.addEventListener("click", async (e) => {
    const widgetId = e.target.closest('[data-widget-id]').dataset.widgetId;
    const removeButton = e.target.closest('mx-button');
    const removeButtonWrapper = e.target.closest('.remove-button-wrapper');
    const addedButton = removeButtonWrapper.querySelector('.added-button');
    const addButton = removeButtonWrapper.parentElement.querySelector('.add-button');
    removeButton.icon = 'icon icon-arrows-clockwise';
    removeButton.classList.replace('opacity-0', 'opacity-100');
    addedButton.classList.add('opacity-0');
    removeButton.querySelector('.button-text').innerText = 'Removing widget'
    removeButton.disabled = true;
    try {
      await destroyUserWidget(widgetId);
      // Replace remove button with add button
      addButton.classList.remove('hidden');
      removeButtonWrapper.classList.add('hidden');
    } catch (err) {
      console.error(err);
    } finally {
      removeButton.classList.replace('opacity-100', 'opacity-0');
      addedButton.classList.remove('opacity-0');
      removeButton.icon = 'icon icon-minus-circle';
      removeButton.querySelector('.button-text').innerText = 'Remove from Dashboard'
      removeButton.disabled = false;
    }
  });
});

function logEvent(eventType, eventData, component = 'widget_panel') {
  _fetch(`/api/events/?session_id=${SESSION_ID}`, {
    method: 'POST',
    body: JSON.stringify({
      event_type: eventType,
      event_data: eventData,
      component,
     })
  });
}

function restoreUserWidget(widgetId) {
  logEvent('widget_add_via_library');
  return _fetch(`/api/user_widgets/${widgetId}/restore?session_id=${SESSION_ID}`, {
    method: 'POST',
  })
}
function destroyUserWidget(widgetId) {
  logEvent('widget_remove_via_library');
  return _fetch(`/api/user_widgets/${widgetId}?session_id=${SESSION_ID}`, {
    method: 'DELETE',
  })
}
async function _fetch(url, options) {
  options = { ...options, headers: { 'Content-Type': 'application/json' } }
  const promise = fetch(url, options);
  activeRequests.push(promise);
  const response = await promise;
  activeRequests = activeRequests.filter((p) => p !== promise);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  } else {
    window.parent.postMessage(
      { type: "SET_LOADING", payload: { component: 'widget_panel', isLoading: true } },
      "*"
    );
    window.parent.postMessage({ type: 'REFRESH', payload: { component: 'widget_panel' } }, "*");
  }
}
</script>
<% end %>
